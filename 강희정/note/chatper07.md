# 7장. 널이 될 수 있는 값

# 7.1 널 가능성

코틀린 → 널 가능성 여부를 타입 시스템에 추가

→ 컴파일러가 관련 오류를 컴파일 시점에 미리 감지 (런타임에 감지하는게 아님)

# 7.2 널이 될 수 있는 타입으로 널이 될 수 있는 변수 명시

코틀린 타입 시스템 → 널이 될 수 있는 타입을 명시적으로 지원

`val x : String? = null` 

- 타입 이름 뒤에 물음표를 붙이면 null 저장 가능
- 실행 시점에 부가 비용이 들지 않는다.

# 7.3 타입의 의미

타입

- 가능한 값의 집합과 그런 값들에 대해 수행할 수 있는 연산의 집합
- 어떤 타입의 변수가 있다면 → 변수에 대한 연산을 컴파일러가 통과시킨다 → 그 연산이 성공적으로 실행된다

자바에서는? → null을 제대로 다루지 못함

- 자바에서 String 타입에는 String과 null이 들어갈 수 있음
- String 타입에서 수행 가능한 연산과 null 타입에서 수행 가능한 연산은 다름
- @Nullable과 @NotNull 어노테이션을 제공하긴 하나, 완전히 믿을 수는 없다.

# 7.4 안전한 호출 연산자로 null 검사와 메서드 호출 합치기: ?.

?.

- null 검사와 메서드 호출을 한 연산으로 수행
    - 프로퍼티 접근에도 사용 가능
- 호출하려는 값이 null이 아니면 일반 메서드 호출처럼 작동
- 호출하려는 값이 null이면 호출은 무시되고 결과값은 null이 된다.
- 안전한 호출의 결과 타입도 nullable한 타입
- chaining해서 사용하는 것도 가능하나, 에러가 발생할 경우 어디에서 null이 발생했는지 알기 어려움 → 주의해서 사용해야 한다.

# 7.5 엘비스 연산자로 null에 대한 기본값 제공: ?:

?: (엘비스 연산자)

- null 대신 사용할 기본값을 지정할 때 사용
- 첫 번째 값이 null
- return, throw 등도 식이기 때문에 넣을 수 있음.

# 7.6 예외를 발생시키지 않고 안전하게 타입을 캐스트하기: as?

as? (안전한 캐스트 연산자)

- as로 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생
- is를 통해 as로 변환 가능한 타입인지 보고 하는건.. 너무 귀찮다..
- as?는 지정한 타입으로 변환할 수 없으면 null 반환

# 7.7 널 아님 단언: !!

- 어떤 값이든 널이 아닌 타입으로 강제로 바꿀 수 있음
- null에 !!을 적용하면 NPE 발생
- null이 아님이 분명한 상황일 때 사용
- 여러 개 연산자를 한 줄에 chaining하는 경우 어떤 연산에서 NPE가 났는지 알기 어려움

# 7.8 let 함수

- 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘길 때 사용
- 널이 될 수 있는 식을 더 쉽게 다룰 수 있음
- 원하는 식을 평가해서 결과가 null인지 검사한 다음 그 결과를 변수에 넣는 작업 간편하게 진ㄱㅎ갱 가능
- 자신의 수신 객체를 인자로 전달 받은 람다에 넘김
    - 널이 아니면 - 널이 아닌 타입을 인자로 받는 람다를 let에 전달

```kotlin
email?.let { email -> sentDmailTo(email) }
```

## 스코프 함수의 비교

| 함수 | x를 어떻게 참조하는지 | 반환값 | 사용처 |
| --- | --- | --- | --- |
| x.let { … } | it | 람다의 결과 | 객체가 null이 아닌 경우에만 코드 블록을 실행하고 싶을 때 |
| x.also { … } | it | x | 빌더 스타일의 API를 사용해 객체 프로퍼티를 설정할 때 |
| x.apply { … } | this | x | 객체에 어떤 동작을 수행한 후 원래 객체를 다른 연산에 사용하고 싶을 때 |
| x.run { … } | this | 람다의 결과 | 객체를 설정한 다음에 별도의 결과를 돌려주고 싶을 때 |
| with(x) { … }  | this | 람다의 결과 | 하나의 객체에 대해 이름을 반복하지 않으면서 여러 함수 호출을 그룹으로 묶고 싶을 때 |

# 7.9 직접 초기화하지 않는 널이 아닌 타입: 지연 초기화 프로퍼티

프로퍼티가 널이 아닌 타입이면 → 반드시 널이 아닌 값으로 초기화 해야 함

그런데 최초에 초기화 하기 어려울 때? - null로 초기화하고 계속 널 검사를 하기 귀찮다

→ 지연 초기화 프로퍼티 lateinit 사용 (유사품: by lazy)

lateinit

- 파이널 필드로 컴파일되며 생성자 안에서 반드시 초기화되어야 함
- 항상 var로 선언되어야 함
- 생성자 안에서 초기화 할 필요가 없음
    - 초기화하지 않고 접근하면 UninitializedPropertyAccessException 발생

# 7.10 안전한 호출 연산자 없이 타입 확장: 널이 될 수 있는 타입에 대한 확장

```kotlin
fun String?.printSafe() {
    if (this == null) {
        println("null 수신 객체입니다.")
    } else {
        println("수신 문자열: $this")
    }
}
```

→ String이 null일 경우에도 정상 동작 한다

- 메서드를 호출하기 전에 수신 객체 역할을 하는 변수가 null이 될 수 없다고 보장
- 메서드 호출이 null을 수신 객체로 받고 내부에서 null을 처리
- 멤버 호출은 객체 인스턴스를 통해 디스패치되므로 그 인스턴스가 null인지 검사하지 않음

# 7.11 타입 파라미터의 널 가능성

모든 타입 파라미터(T)는 null이 될 수 있음!

→ 코틀린 타입의 유일한 예외. 물음표가 붙지 않아도 널이 올 수 있다.

널을 넣지 않으려면? → 타입의 upper bound 지정

```kotlin
fun <T: Any> printHashCode(t: T) // T는 널이 될 수 없는 타입
```

# 7.12 널 가능성과 자바

자바의 @NotNull, @Noullable은 코틀린에서 잘 알아볼 수 있다.

그런데 매번 이 어노테이션들이 붙어 있을 리가 없다..

## 7.12.1 플랫폼 타입

- 코틀린이 널 관련 정보를 알 수 없는 타입
- 타입 뒤에 느낌표가 붙는다
    - `String!`
- 직접 정의할 수는 없고, 자바에서 넘어온 타입이 이렇게 보인다.
- 널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.

→ 개발자가 주의해서 직접 처리해야 함!

플랫폼 타입을 도입한 이유

→ 매번 널 가능성을 판단하는데 드는 비용보다 개발자가 신경을 더 쓰는게 비용이 적게 든다.