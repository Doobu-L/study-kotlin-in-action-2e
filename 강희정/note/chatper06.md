# 6장. 컬렉션과 시퀀스

# 6.1 컬렉션에 대한 함수형 API

## 6.1.1 filter, map

### filter

- predicate를 바탕으로 컬렉션의 원소를 걸러갬
- 컬렉션을 순회하면서 주어진 람다가 true를 반환하는 원소들만 모음
- 필터링 하는 과정에서 원소를 변환하지는 않음

```kotlin
list.filter{ it % 2 == 0  }
```

### map

- 입력 컬렉션의 원소를 변환
- 주어진함수를 컬렉션의 각 원소에 적용하고 결과값을새 컬렉션에 모음
- 원본 컬렉션과 길이는 같지만 변환된 새로운 컬렉션이 생김

```kotlin
list.map{ it * it }
```

→ 이 두 함수들은 멤버 참조를 이용해서 사용할 수 있음

```kotlin
people.map(Person::name)
```

filterIndexed, mapIndexed

- 잘라내거나 변환하는 연산이 원소의 값 뿐만 아니라 인덱스에 따라서도 달라질 경우 사용

filterKeys, mapKeys

- 맵의 키를 걸러내거나 변환

filterValues, mapValues

- 맵의 값을 걸러내거나 변환

## 6.1.2 reduce, fold

- 컬렉션의 정보를 종합할 때 사용
- 원소로 이뤄진 컬렉션을 받아서 하나의 값을 반환
- 누적기를 통해 점진적으로 만들어짐
- 람다는 각 원소에 대해 호출되며, 새로운 누적 값을 반환해야 함

### reduce

- 컬렉션의 첫 번째 값을 누적기에 넣음
- 그 후 람다가 호출되면서 누적 값과 2번째 원소가 인자로 전달됨

```kotlin
list.reduce{ acc, element -> acc * element }
```

### fold

- 임의의 시작 값 선택 가능

```kotlin
people.fold("") { acc, person ->
		acc + person.name
}
```

→ reduce, fold는 결괏값을 하나만 반환

runningReduce, runningFold

- 중간 단계의 모든 누적 값을 뽑아내고 싶을 때 사용
- 결과값의 리스트를 반환 → 최종 결과와 함께 모든 중간 누적값이 들어감

## 6.1.3 all, any, none, count, find

all, any, none

- 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산
- 드 모르간의 법칙 - !all을 수행한 결과와 조건의 보정에 대해 any를 수행한 결과는 같다
    - `!list.add { it == 3}` 과 `list.any { it ≠ 3}` 은 같음
    - !any를 none으로 바꿀 수 있음

빈 컬렉션에서의 동작

- any
    - false 반환
    - 컬렉션에 원소가 없으면 predicate식을 만족하는 원소도 없음
- none
    - true 반환
    - predicate 식을 만족할 수 있는 원소가 없음
- all
    - **true 반환**
    - predicate 식을 만족하지 못하는 원소가 무엇인지 알 수 없음

count

- 조건을 만족하는 원소의 개수를 반환
- filter 후 size를 쓰면 중간 컬렉션이 생김 → 이 경우 count를 사용하는 것이 좋다.

find

- 조건을 만족하는 첫 번째 원소를 반환
- firstOrNull과 같다. 조건을 만족하는 원소가 없을 때 Null을 반환한다.

## 6.1.4 partition

- 컬렉션을 어떤 술어를 만족하는 그룹과 / 술어를 만족하지 못하는 그룹으로 나눌 때 사용
- 두 리스트의 쌍을 내놓는다

```kotlin
val (comeIn, stayOut) = people.partition(canBeInClub27) // 반환된 리스트의 쌍을 저장
```

## 6.1.5 groupBy

- 특성에 따라 여러 그룹으로 나눔

```kotlin
people.groupBy { it.age }
```

- 위 예제 결과의 타입은 Map<Int, List<person>>
- 각 그룹은 리스트에 저장됨

## 6.1.6 associate, associateWith, associateBy

- 원소를 그룹화하지 않으면서 컬렉션으로부터 맵을 만들어내고 싶을 때
- 입력 컬렉션의 원소로부터 키/값 쌍을 만들어내는 람다를 제공

```kotlin
people.associate {it.name to it.age }
```

- associateWith
    - 컬렉션의 원래 원소를 키로 사용
    - 람다는 원소에 대응하는 값을 만듦
- associateBy
    - 컬렉션의 원래 원소를 맵의 값으로 함
    - 람다가 만들어내는 값을 맵의 키로 사용
- 변환 함수가 키가 같은 값을 여러 번 추가하게 되면 마지막 결과가 그 이전에 들어간 결과를 덮어쓰게 됨

## 6.1.7 replaceAll, fill

replaceAll

- mutableList에 적용 시, 람다로 얻은 결과로 컬렉션의 모든 원소를 변경

fill

- 가변 리스트의 모든 원소를 똑같은 값으로 변경

## 6.1.8 ifEmpty

컬렉션에 아무 원소도 없을 때 기본값을 생성하는 람다 제공

ifBlank → 공백 감지

## 6.1.9 chunked, windowed

데이터를 연속적인 시간의 값으로 처리하고 싶을 때 사용

- windowed
    - 슬라이딩 윈도우를 생성하고자 할 때 사용
    - 선택적으로 출력을 변환할 수 있는 람다 전달
    
    ```kotlin
    println(temperatures.windowed(3))
    println(temperatures.windowed(3) {it.sum() / it.size})
    ```
    
- chunked
    - 컬렉션을 주어진 크기의 서로 겹치지 않는 부분으로 나누고 싶을 때 사용
    - 람다를 전달하며, 람다는 출력을 변환함
    - 남은 원소는 마지막 청크에 들어감
    
    ```kotlin
    println(temperatures.chunked(2))
    ```
    

## 6.1.10 zip

- 연관이 있는 데이터가 들어있는 별도의 두 리스트를 종합할 때 사용
- 서로의 인덱스에 따라 대응된다고 알고 있을 때 사용
- 두 컬렉션에서 같은 인덱스에 있는 원소들의 쌍으로 이루어진 리스트를 만듦
- 람다를 전달하면 출력 변환 가능
- 반대편 컬렉션에 대응하는 원소가 없는 원소를 무시
- 두 입력 컬렉션 중 더 짧은 쪽의 길이와 같다
- 중위 표기법으로 호출이 가능하나, 중위 표기법을 쓸 때는 람다 전달 불가
    - `println(names zip ages)`
- 연쇄시켜 호출하면 2개의 리스트보다 더 많은 리스트를 합칠 수 있음
    - 이 경우 중첩 리스트가 된다.. 주의할 것

## 6.1.11 flatMap, flatten

flatMap

- 컬렉션의 원소를 파라미터로 주어진 함수를 사용해 변환(매핑)
- 변환한 결과를 하나의 리스트로 합친다(펼친다)
- 컬렉션의 컬렉션을 평평한 리스트로 변환

flatten

- 변환할 것이 없이 단순히 평평한 리스트로 변환할 때 사용

# 6.2 시퀀스

컬렉션 함수의 연쇄 호출 → 컬렉션을 즉시(eagerly) 생성

시퀀스 → 중간 임시 컬렉션을 사용하지 않고 컬렉션 연산을 연쇄

Sequence 인터페이스

- 한 번에 하나씩 열거될 수 있는 원소의 시퀀스 표현
- iterator 메서드 가지고 있음 → 메서드를 통해 시퀀스에서 원소 값을 얻을 수 있음
- 시퀀스의 원소는 필요할 때 lazy하게 계산됨
- 중간 처리 결과를 저장할 컬렉션을 만들지 않고도 연산을 연쇄적으로 사용 → 연쇄적인 연산을 효율적으로 수행

asSequence

- 어떤 컬렉션이든 시퀀스로 변환 가능

toList

- 시퀀스를 리스트로 만들 때 사용

→ 항상 시퀀스가 좋은 것은 아니고, 상황에 따라 다르다.

## 6.2.1 시퀀스 연산 실행: 중간 연산과 최종 연산

중간 연산

- 다른 시퀀스를 변환
- 최초 시퀀스의 원소를 변환하는 방법을 알고 있음
- 항상 지연 계산

최종 연산

- 결과를 반환
- 최초 컬렉션에 대해 변환을 적용한 시퀀스에서 → 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 수, 또는 다른 객체
- 호출하면 연기되었던 모든 계산이 수행

시퀀스 사용 → 지연 계산으로 인해 원소 중 일부의 계산이 이뤄지지 않을 수 있음

- 시퀀스의 경우 모든 연산은 각 원소에 대해 순차적으로 적용
- 컬렉션은 모든 원소가 변환

![image.png](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3%201abe9cff7f9d800c9cfdea71dd0ec5fb/image.png)

## 6.2.2 시퀀스 만들기

generateSequence

- 이전의 원소를 인자로 받아 다음 원소를 계산
-