# PART_4 클래스,객체,인터페이스
<br><br>
<hr>

## 다루는 내용

>- 클래스와 인터페이스
>- 뻔하지 않은 생성자와 프로퍼티
>- 데이터 클래스
>- 클래스 위임
>- object 키워드 사용

<hr>
<br><br>

### 4.1 클래스 계층 정의
### 4.1.1 코틀린 인터페이스

```kotlin
interface Clickable {
  fun click()
}

class Button : Clickable {
  override fun click() = println("I was clicked")
}
```

- 인터페이스를 원하는 갯수 만큼 제한 없이 구현할 수 있지만 클래스는 오직 하나만 확장할 수 있다.
- 두 인터페이스에 같은 메소드를 제공한 경우 어느쪽도 선택되지 않는다. 명시적으로 새로 구현해야 하며 super<>.showOff() 와 같은 형태로 지정 가능

### 4.1.2 open, final, abstract 변경자: 기본적으로 final
- 코틀린에서 모든 클래스와 메소드는 기본적으로 final 이다.

### 4.1.3 가시성 변경자: 기본적으로 공개
- default 가시성 변경자는 public 이다.
- internal 가시성을 제공
- 가시성은 자신의 가시성과 같거나 더 높아야 한다.
- protected 멤버는 오직 어떤 클래스나 그 클래스를 상송한 클래스 안에서만 보인다.

### 4.1.4 내부 클래스와 내포된 클래스: 기본적으로 내포 클래스
- 코틀린의 inner class 는 외부 클래스의 참조를 갖지 않는다. inner class 로 선언해야 한다.

### 4.1.5 봉인된 클래스: 확장이 제한된 클래스 계층 정의
- sealed 봉인된 클래스, 하위 클래스의 가능성을 제한할 수 있다.
- default 분기가 필요 없다.
- sealed 변경자는 클래스가 추상 클래스이다.

### 4.2 뻔하지 않은 생성자나 프로퍼티를 갖는 클래스 선언
- 코틀린은 주 생성자와 부 생성자를 구분한다.

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록
- init 초기화 블록에서만 주 생성자의 파라미터를 참조할 수 있다.
- 비공개 생성자에 대한 대안으로 주 생성자에 private 을 선언하면 된다.

### 4.2.2 부 생성자: 상위 클래스를 다른 방식으로 초기화
- 부 생성자를 여럿 만들지 말라. 대신 파라미터의 기본값을 생성자 시그니처에 직접 명시하라.
- 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른생성자에게 생성을 위임해야 한다.

### 4.2.3 인터페이스에 선언된 프로퍼티 구현

함수 대신 프로퍼티를 사용하는 경우:
- 예외를 던지지 않는다.
- 계산 비용이 적게 든다.(또는 최초 실행 후 결과를 캐시해 사용할 수 있다.)
- 객체 상태가 바뀌지 않으면 여러 번 호출해도 항상 같은 결과를 돌려준다.

### 4.2.4 게터와 세터에서 뒷받침하는 필드에 접근
- $field 키워드를 사용해 뒷받침하는 필드에 접근할 수 있다.
- 뒷 받침하는 필드에 접근하지 않으면 컴파일러는 뒷 받침하는 필드를 생성하지 않는다.

### 4.2.5 접근자의 가시성 변경
```kotlin
class LengthCounter {
    var counter: Int = 0
      private set
  
  fun addWord(word: String) {
      counter += word.length
  }
}
```

### 4.3 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임
### 4.3.1 모든 클래스가 정의해야 하는 메서드
- java 의 ==와 코틀린의 ===는 같음.

### 4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메서드를 자동으로 생성
```kotlin
data class Customer(val name: String, val postalCode: Int)
```
- toString, equals, hashCode 메서드를 자동으로 생성해준다.
- 프로퍼티는 불변을 권장.
- copy 메서드 제공
- by 키워드를 통해 위임 중이라는 사실을 명시할 수 있다. 데코레이터 패턴을 사용할 때 모든 메소드를 직접 구현하지 않아도 된다.

### 4.4 object 키워드: 클래스 선언과 인스턴스 생성을 한꺼번에 하기

### 4.4.1 객체 선언: 싱글턴을 쉽게 만들기
싱글턴 예시
```kotlin
object Payroll {
    val allEmployees = arrayListOf<Person>()
  
  fun calculateSalary() {
      for (person in allEmployees) {
          /* ... */
      }
  }
}
```
- 생성자 사용 불가능

### 4.4.2 동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소
- 코틀린 클래스 안에는 정적인 멤버가 없다.
- companion 키워드를 사용하여 정적멤버 선언

### 4.4.3 동반 객체를 일반 객체처럼 사용
- 클래스의 동반 객체는 일반 객체와 비슷한 방식으로, 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일 된다.

### 4.4.4 객체 식: 익명 내부 클래스를 다른 방식으로 작성
- object 를 익명 객체로 사용 가능

### 4.5 부가 비용 없이 타입 안전성 추가: 인라인 클래스
```kotlin
@JvmInlinevalue class UsdCent(val amount: Int)
```
- 인라인 클래스는 클래스 계층에 참여하지 않는다.
